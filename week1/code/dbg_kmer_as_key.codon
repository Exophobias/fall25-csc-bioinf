def reverse_complement(key: str) -> str:
    complement = {'A': 'T', 'T': 'A', 'G': 'C', 'C': 'G'}
    
    result_list: List[str] = []
    for i in range(len(key) - 1, -1, -1):
        result_list.append(complement.get(key[i], key[i]))
    return ''.join(result_list)


class Node:
    _children: Set[str]
    _count: int
    visited: bool
    depth: int
    max_depth_child: Optional[str]
    
    def __init__(self):
        self._children = set()
        self._count = 0
        self.visited = False
        self.depth = 0
        self.max_depth_child = None
    
    def add_child(self, kmer: str):
        self._children.add(kmer)
    
    def increase(self):
        self._count += 1
    
    def reset(self):
        self.visited = False
        self.depth = 0
        self.max_depth_child = None
    
    def get_count(self) -> int:
        return self._count
    
    def get_children(self) -> List[str]:
        return list(self._children)
    
    def remove_children(self, target: Set[str]):
        self._children = self._children - target


class DBG:
    k: int
    nodes: Dict[str, Node]
    
    def __init__(self, k: int, data_list: List[List[str]]):
        self.k = k
        self.nodes = {}
        self._check(data_list)
        self._build(data_list)
    
    def _check(self, data_list: List[List[str]]):
        assert len(data_list) > 0
        assert self.k <= len(data_list[0][0])
    
    def _build(self, data_list: List[List[str]]):
        for data in data_list:
            for original in data:
                rc = reverse_complement(original)
                for i in range(len(original) - self.k - 1):
                    self._add_arc(original[i: i + self.k], original[i + 1: i + 1 + self.k])
                    self._add_arc(rc[i: i + self.k], rc[i + 1: i + 1 + self.k])
    
    def _add_node(self, kmer: str):
        if kmer not in self.nodes:
            self.nodes[kmer] = Node()
        self.nodes[kmer].increase()
    
    def _add_arc(self, kmer1: str, kmer2: str):
        self._add_node(kmer1)
        self._add_node(kmer2)
        self.nodes[kmer1].add_child(kmer2)
    
    def _get_count(self, child: str) -> int:
        return self.nodes[child].get_count()
    
    def _get_sorted_children(self, kmer: str) -> List[str]:
        children = self.nodes[kmer].get_children()
        # Sort children by count in descending order
        sorted_children: List[str] = []
        for child in children:
            sorted_children.append(child)
        
        # Simple bubble sort for sorting by count
        n = len(sorted_children)
        for i in range(n):
            for j in range(0, n - i - 1):
                if self._get_count(sorted_children[j]) < self._get_count(sorted_children[j + 1]):
                    sorted_children[j], sorted_children[j + 1] = sorted_children[j + 1], sorted_children[j]
        
        return sorted_children
    
    def _get_depth(self, kmer: str) -> int:
        if not self.nodes[kmer].visited:
            self.nodes[kmer].visited = True
            children = self._get_sorted_children(kmer)
            max_depth = 0
            max_child: Optional[str] = None
            for child in children:
                depth = self._get_depth(child)
                if depth > max_depth:
                    max_depth = depth
                    max_child = child
            self.nodes[kmer].depth = max_depth + 1
            self.nodes[kmer].max_depth_child = max_child
        return self.nodes[kmer].depth
    
    def _reset(self):
        for kmer in self.nodes:
            self.nodes[kmer].reset()
    
    def _get_longest_path(self) -> List[str]:
        max_depth = 0
        max_kmer: Optional[str] = None
        for kmer in self.nodes:
            depth = self._get_depth(kmer)
            if depth > max_depth:
                max_depth = depth
                max_kmer = kmer
        
        path: List[str] = []
        while max_kmer is not None:
            path.append(max_kmer)
            max_kmer = self.nodes[max_kmer].max_depth_child
        return path
    
    def _delete_path(self, path: List[str]):
        path_set = set(path)
        # Get list of kmers to iterate over (to avoid modifying dict during iteration)
        kmers_to_process: List[str] = []
        for kmer in self.nodes:
            kmers_to_process.append(kmer)
        
        # Remove nodes in path from children of other nodes
        for kmer in kmers_to_process:
            if kmer not in path_set and kmer in self.nodes:
                self.nodes[kmer].remove_children(path_set)
        
        # Delete nodes in path
        for kmer in path:
            if kmer in self.nodes:
                del self.nodes[kmer]
    
    def _concat_path(self, path: List[str]) -> Optional[str]:
        if len(path) < 1:
            return None
        concat = str(path[0])
        for i in range(1, len(path)):
            concat += path[i][-1]
        return concat
    
    def get_longest_contig(self) -> Optional[str]:
        self._reset()
        path = self._get_longest_path()
        contig = self._concat_path(path)
        self._delete_path(path)
        return contig